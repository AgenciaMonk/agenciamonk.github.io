{
  "_args": [
    [
      {
        "raw": "phridge@~2.0.0",
        "scope": null,
        "escapedName": "phridge",
        "name": "phridge",
        "rawSpec": "~2.0.0",
        "spec": ">=2.0.0 <2.1.0",
        "type": "range"
      },
      "/Users/Monk/Desktop/GUSTAVO/site-grid/monk-framework/node_modules/uncss"
    ]
  ],
  "_from": "phridge@>=2.0.0 <2.1.0",
  "_id": "phridge@2.0.0",
  "_inCache": true,
  "_location": "/phridge",
  "_nodeVersion": "5.5.0",
  "_npmUser": {
    "name": "peerigon",
    "email": "developers@peerigon.com"
  },
  "_npmVersion": "3.3.12",
  "_phantomChildren": {},
  "_requested": {
    "raw": "phridge@~2.0.0",
    "scope": null,
    "escapedName": "phridge",
    "name": "phridge",
    "rawSpec": "~2.0.0",
    "spec": ">=2.0.0 <2.1.0",
    "type": "range"
  },
  "_requiredBy": [
    "/uncss"
  ],
  "_resolved": "https://registry.npmjs.org/phridge/-/phridge-2.0.0.tgz",
  "_shasum": "aba7392945242fb495277d70e76c4b97e4285bb6",
  "_shrinkwrap": null,
  "_spec": "phridge@~2.0.0",
  "_where": "/Users/Monk/Desktop/GUSTAVO/site-grid/monk-framework/node_modules/uncss",
  "author": {
    "name": "peerigon",
    "email": "developers@peerigon.com"
  },
  "bugs": {
    "url": "https://github.com/peerigon/phridge/issues"
  },
  "dependencies": {
    "fork-stream": "^0.0.4",
    "linerstream": "^0.1.4",
    "phantomjs-prebuilt": "^2.1.3",
    "temp": "^0.8.0"
  },
  "description": "A bridge between node and phantomjs",
  "devDependencies": {
    "chai": "^3.2.0",
    "chai-as-promised": "^5.1.0",
    "eslint": "^1.6.0",
    "eslint-config-peerigon": "^2.0.0",
    "getport": "^0.1.0",
    "istanbul": "^0.4.2",
    "mocha": "^2.2.5",
    "ps-node": "^0.0.5",
    "sinon": "^1.14.1",
    "sinon-chai": "^2.7.0"
  },
  "directories": {},
  "dist": {
    "shasum": "aba7392945242fb495277d70e76c4b97e4285bb6",
    "tarball": "https://registry.npmjs.org/phridge/-/phridge-2.0.0.tgz"
  },
  "gitHead": "0aa95f81dffcaab48357ebf2aab42ce64ce69247",
  "homepage": "https://github.com/peerigon/phridge#readme",
  "keywords": [
    "phantom",
    "phantomjs",
    "bridge",
    "driver"
  ],
  "license": "Unlicense",
  "main": "./lib/main.js",
  "maintainers": [
    {
      "name": "peerigon",
      "email": "developers@peerigon.com"
    }
  ],
  "name": "phridge",
  "optionalDependencies": {},
  "readme": "phridge\n=======\n**A bridge between [node](http://nodejs.org/) and [PhantomJS](http://phantomjs.org/).**\n\n[![](https://img.shields.io/npm/v/phridge.svg)](https://www.npmjs.com/package/phridge)\n[![](https://img.shields.io/npm/dm/phridge.svg)](https://www.npmjs.com/package/phridge)\n[![Dependency Status](https://david-dm.org/peerigon/phridge.svg)](https://david-dm.org/peerigon/phridge)\n[![Build Status](https://travis-ci.org/peerigon/phridge.svg?branch=master)](https://travis-ci.org/peerigon/phridge)\n[![Coverage Status](https://img.shields.io/coveralls/peerigon/phridge.svg)](https://Coveralls.io/r/peerigon/phridge?branch=master)\n\nWorking with PhantomJS in node is a bit cumbersome since you need to spawn a new PhantomJS process for every single task. However, spawning a new process is quite expensive and thus can slow down your application significantly.\n\nphridge provides an api to easily\n\n- spawn new PhantomJS processes\n- run functions with arguments inside PhantomJS\n- return results from PhantomJS to node\n- manage long-running PhantomJS instances\n\nUnlike other node-PhantomJS bridges phridge provides a way to run code directly inside PhantomJS instead of turning every call and assignment into an async operation.\n\nphridge uses PhantomJS' stdin and stdout for [inter-process communication](http://en.wikipedia.org/wiki/Inter-process_communication). It stringifies the given function, passes it to PhantomJS via stdin, executes it in the PhantomJS environment and passes back the results via stdout. Thus you can write your PhantomJS scripts inside your node modules in a clean and synchronous way.\n\nInstead of ...\n\n```javascript\nphantom.addCookie(\"cookie_name\", \"cookie_value\", \"localhost\", function () {\n    phantom.createPage(function (page) {\n        page.set(\"customHeaders.Referer\", \"http://google.com\", function () {\n            page.set(\n                \"settings.userAgent\",\n                \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_5)\",\n                function () {\n                    page.open(\"http://localhost:9901/cookie\", function (status) {\n                        page.evaluate(function (selector) {\n                            return document.querySelector(selector).innerText;\n                        }, function (text) {\n                            console.log(\"The element contains the following text: \"+ text)\n                        }, \"h1\");\n                    });\n                }\n            );\n        });\n    });\n});\n```\n\n... you can write ...\n\n```javascript\n// node\nphantom.run(\"h1\", function (selector, resolve) {\n    // this code runs inside PhantomJS\n\n    phantom.addCookie(\"cookie_name\", \"cookie_value\", \"localhost\");\n\n    var page = webpage.create();\n    page.customHeaders = {\n        Referer: \"http://google.com\"\n    };\n    page.settings = {\n        userAgent: \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_5)\"\n    };\n    page.open(\"http://www.google.com\", function () {\n        var text = page.evaluate(function (selector) {\n            return document.querySelector(selector).innerText;\n        }, selector);\n\n        // resolve the promise and pass 'text' back to node \n        resolve(text);\n    });\n}).then(function (text) {\n    // inside node again\n    console.log(\"The element contains the following text: \" + text);\n});\n```\n\nPlease note that the `phantom`-object provided by phridge is completely different to the `phantom`-object inside PhantomJS. So is the `page`-object. [Check out the api](#api-phantom) for further information.\n\n<br />\n\nInstallation\n------------------------------------------------------------------------\n\n`npm install phridge`\n\n<br />\n\nExamples\n------------------------------------------------------------------------\n\n### Spawn a new PhantomJS process\n\n```javascript\nphridge.spawn({\n    proxyAuth: \"john:1234\",\n    loadImages: false,\n    // passing CLI-style options does also work\n    \"--remote-debugger-port\": 8888\n}).then(function (phantom) {\n    // phantom is now a reference to a specific PhantomJS process\n});\n```\n\n`phridge.spawn()` takes an object which will be passed as config to PhantomJS. Check out [their documentation](http://phantomjs.org/api/command-line.html) for a detailed overview of options. CLI-style options are added as they are, so be sure to escape the space character.\n\n*Please note: There are [known issues](https://github.com/peerigon/phridge/issues/31) of PhantomJS that some config options are only supported in CLI-style.*\n\n### Run any function inside PhantomJS\n\n```javascript\nphantom.run(function () {\n    console.log(\"Hi from PhantomJS\");\n});\n```\n\nphridge stringifies the given function, sends it to PhantomJS and evals it again. Hence you can't use scope variables:\n\n```javascript\nvar someVar = \"hi\";\n\nphantom.run(function () {\n    console.log(someVar); // throws a ReferenceError\n});\n```\n\n### Passing arguments\n\nYou can also pass arguments to the PhantomJS process:\n\n```javascript\nphantom.run(\"hi\", 2, {}, function (string, number, object) {\n    console.log(string, number, object); // 'hi', 2, [object Object]\n});\n```\n\nArguments are stringified by `JSON.stringify()`, so be sure to use JSON-valid objects.\n\n### Returning results\n\nThe given function can run sync and async. However, the `run()` method itself will always run async as it needs to wait for the process to respond.\n\n**Sync**\n\n```javascript\nphantom.run(function () {\n    return Math.PI;\n}).then(function (pi) {\n    console.log(pi === Math.PI); // true\n});\n```\n\n**Async**\n\n```javascript\nphantom.run(function (resolve) {\n    setTimeout(function () {\n        resolve(\"after 500 ms\");\n    }, 500);\n}).then(function (msg) {\n    console.log(msg); // 'after 500 ms'\n});\n```\n\nResults are also stringified by `JSON.stringify()`, so returning application objects with functions won't work.\n\n```javascript\nphantom.run(function () {\n    ...\n    // doesn't work because page is not a JSON-valid object\n    return page;\n});\n```\n\n### Returning errors\n\nErrors can be returned by using the `throw` keyword or by calling the `reject` function. Both ways will reject the promise returned by `run()`.\n\n**Sync**\n\n```javascript\nphantom.run(function () {\n    throw new Error(\"An unknown error occured\");\n}).catch(function (err) {\n    console.log(err); // 'An unknown error occured'\n});\n```\n\n**Async**\n\n```javascript\nphantom.run(function (resolve, reject) {\n    setTimeout(function () {\n        reject(new Error(\"An unknown error occured\"));\n    }, 500);\n}).catch(function (err) {\n    console.log(err); // 'An unknown error occured'\n});\n```\n\n### Async methods with arguments\n\n`resolve` and `reject` are just appended to the regular arguments:\n\n```javascript\nphantom.run(1, 2, 3, function (one, two, three, resolve, reject) {\n\n});\n```\n\n### Persisting states inside PhantomJS\n\nSince the function passed to `phantom.run()` can't declare variables in the global scope, it is impossible to maintain state in PhantomJS. That's why `phantom.run()` calls all functions on the same context object. Thus you can easily store state variables.\n\n```javascript\nphantom.run(function () {\n    this.message = \"Hello from the first call\";\n}).then(function () {\n    phantom.run(function () {\n        console.log(this.message); // 'Hello from the first call'\n    });\n});\n```\n\nFor further convenience all PhantomJS modules are already available in the global scope.\n\n```javascript\nphantom.run(function () {\n    console.log(webpage);           // [object Object]\n    console.log(system);            // [object Object]\n    console.log(fs);                // [object Object]\n    console.log(webserver);         // [object Object]\n    console.log(child_process);     // [object Object]\n});\n```\n\n### Working in a page context\n\nMost of the time its more useful to work in a specific webpage context. This is done by creating a Page via `phantom.createPage()` which calls internally `require(\"webpage\").create()`. The returned page wrapper will then execute all functions bound to a PhantomJS [webpage instance](http://phantomjs.org/api/webpage/). \n\n```javascript\nvar page = phantom.createPage();\n\npage.run(function (resolve, reject) {\n    // `this` is now a webpage instance\n    this.open(\"http://example.com\", function (status) {\n        if (status !== \"success\") {\n            return reject(new Error(\"Cannot load \" + this.url));\n        }\n        resolve();\n    });\n});\n```\n\nAnd for the busy ones: You can just call `phantom.openPage(url)` which is basically the same as above:\n\n```javascript\nphantom.openPage(\"http://example.com\").then(function (page) {\n    console.log(\"Example loaded\");\n});\n``` \n\n### Cleaning up\n\nIf you don't need a particular page anymore, just call:\n\n```javascript\npage.dispose().then(function () {\n    console.log(\"page disposed\");\n});\n```\n\nThis will clean up all page references inside PhantomJS.\n\nIf you don't need the whole process anymore call\n\n```javascript\nphantom.dispose().then(function () {\n    console.log(\"process terminated\");\n});\n```\n\nwhich will terminate the process cleanly by calling `phantom.exit(0)` internally. You don't need to dispose all pages manuallly when you call `phantom.dispose()`.\n\nHowever, calling\n\n```javascript\nphridge.disposeAll().then(function () {\n    console.log(\"All processes created by phridge.spawn() have been terminated\");\n});\n```\n\nwill terminate all processes.\n\n**I strongly recommend to call** `phridge.disposeAll()` **when the node process exits as this is the only way to ensure that all child processes terminate as well.** Since `disposeAll()` is async it is not safe to call it on `process.on(\"exit\")`. It is better to call it on `SIGINT`, `SIGTERM` and within your regular exit flow.\n\n<br />\n\nAPI\n----\n\n### phridge\n\n#### .spawn(config?): Promise → Phantom\n\nSpawns a new PhantomJS process with the given config. [Read the PhantomJS documentation](http://phantomjs.org/api/command-line.html) for all available config options. Use camelCase style for option names. The promise will be fulfilled with an instance of `Phantom`.\n\n#### .disposeAll(): Promise\n\nTerminates all PhantomJS processes that have been spawned. The promise will be fulfilled when all child processes emitted an `exit`-event.\n\n#### .config.stdout: Stream = process.stdout\n\nDestination stream where PhantomJS' [clean stdout](#phantom-childprocess-cleanstdout) will be piped to. Set it `null` if you don't want it. Changing the value does not affect processes that have already been spawned.\n\n#### .config.stderr: Stream = process.stderr\n\nDestination stream where PhantomJS' stderr will be piped to. Set it `null` if you don't want it. Changing the value does not affect processes that have already been spawned.\n\n----\n\n### <a name=\"api-phantom\"></a>Phantom.prototype\n\n#### .childProcess: ChildProcess\n\nA reference to the [ChildProcess](http://nodejs.org/api/child_process.html#child_process_class_childprocess)-instance.\n\n#### <a name=\"phantom-childprocess-cleanstdout\"></a> .childProcess.cleanStdout: ReadableStream\n\nphridge extends the [ChildProcess](http://nodejs.org/api/child_process.html#child_process_class_childprocess)-instance by a new stream called `cleanStdout`. This stream is piped to `process.stdout` by default. It provides all data not dedicated to phridge. Streaming data is considered to be dedicated to phridge when the new line is preceded by the classifier string `\"message to node: \"`.\n\n#### <a name=\"phantom-run\"></a>.run(args..., fn): Promise → *\n\nStringifies `fn`, sends it to PhantomJS and executes it there again. `args...` are stringified using `JSON.stringify()` and passed to `fn` again. `fn` may simply `return` a result or `throw` an error or call `resolve()` or `reject()` respectively if it is asynchronous. phridge compares `fn.length` with the given number of arguments to determine whether `fn` is sync or async. The returned promise will be resolved with the result or rejected with the error.\n\n#### .createPage(): Page\n\nCreates a wrapper to execute code in the context of a specific [PhantomJS webpage](http://phantomjs.org/api/webpage/).\n\n#### .openPage(url): Promise → Page\n\nCalls `phantom.createPage()`, then `page.open(url, cb)` inside PhantomJS and resolves when `cb` is called. If the returned `status` is not `\"success\"` the promise will be rejected.\n\n#### .dispose(): Promise\n\nCalls `phantom.exit(0)` inside PhantomJS and resolves when the child process emits an `exit`-event.\n\n### Events\n\n#### unexpectedExit\n\nWill be emitted when PhantomJS exited without a call to `phantom.dispose()` or one of its std streams emitted an `error` event. This event may be fired on some OS when the process group receives a `SIGINT` or `SIGTERM` (see [#35](https://github.com/peerigon/phridge/pull/35)).\n\nWhen an `unexpectedExit` event is encountered, the `phantom` instance will be unusable and therefore automatically disposed. Usually you don't need to listen for this event.\n\n---\n\n### Page.prototype\n\n#### .phantom: Phantom\n\nA reference to the parent [`Phantom`](#api-phantom) instance.\n\n#### .run(args..., fn): Promise → *\n\nCalls `fn` on the context of a PhantomJS page object. See [`phantom.run()`](#phantom-run) for further information.\n\n#### .dispose(): Promise\n\nCleans up this page instance by calling `page.close()`\n\n<br />\n\nContributing\n------------------------------------------------------------------------\n\nFrom opening a bug report to creating a pull request: **every contribution is appreciated and welcome**. If you're planing to implement a new feature or change the api please create an issue first. This way we can ensure that your precious work is not in vain.\n\nAll pull requests should have 100% test coverage (with notable exceptions) and need to pass all tests.\n\n- Call `npm test` to run the unit tests\n- Call `npm run coverage` to check the test coverage (using [istanbul](https://github.com/gotwarlost/istanbul))  \n\n<br />\n\nLicense\n------------------------------------------------------------------------\n\nUnlicense\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/peerigon/phridge.git"
  },
  "scripts": {
    "coverage": "istanbul cover ./node_modules/mocha/bin/_mocha",
    "posttest": "eslint examples lib test",
    "test": "mocha -R spec"
  },
  "version": "2.0.0"
}
